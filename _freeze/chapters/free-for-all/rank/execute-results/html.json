{
  "hash": "d585189761a0a6d27b36b26a302f0317",
  "result": {
    "engine": "knitr",
    "markdown": "# Rank Models\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidyverse\"); theme_set(theme_bw())\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'purrr' was built under R version 4.4.1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4.9000     ✔ readr     2.1.5     \n✔ forcats   1.0.0          ✔ stringr   1.5.1     \n✔ ggplot2   3.5.1          ✔ tibble    3.2.1     \n✔ lubridate 1.9.3          ✔ tidyr     1.3.1     \n✔ purrr     1.0.4          \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(\"ggResidpanel\")\nlibrary(\"emmeans\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWelcome to emmeans.\nCaution: You lose important information if you filter this package's results.\nSee '? untidy'\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(\"lme4\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Matrix\n\nAttaching package: 'Matrix'\n\nThe following objects are masked from 'package:tidyr':\n\n    expand, pack, unpack\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(\"DT\")\n\noptions(width = 120)\n```\n:::\n\n\n\n## Models\n\nLet $Y_{a,e}$ be the rank for athlete $a$ in event $e$ with 1 indicating the \nfastest time and higher numbers indicating slower times.\nTo build a model for the ranks, we will introduce a latent variable \n$\\zeta_{a,e}$ with the order statistics \n$\\zeta_{a,e,(1)}, \\ldots, \\zeta_{a,e,(N_e)}$\nwhere $N_e$ are the number of athletes in event $e$. \nThe order statistics are such that \n$$\\zeta_{a,e,(1)} < \\zeta_{a,e,(2)} < \\cdots < \\zeta_{a,e,(N_e)}.$$\nWe then define the athletes rank in terms of these order statistics to be\n$$Y_{a,e} = \\arg_r \\{r: \\zeta_{a,e} = \\zeta_{a,e,(r)}\\}.$$\nThe latent variable $\\zeta_{a,e}$ is related to the time in the event in the \nsense that if we had the time in the event, we would just use it rather than\nusing these $\\zeta_{a,e}s$. \n\nNow, we need to build a model for the $\\zeta_{a,e}$ for each athlete. \nWe assume\n$$\\zeta_{a,e} \\stackrel{ind}{\\sim} N(\\theta_a, 1).$$\nSo the athlete performance at a given event is a draw from a normal distribution\nwhose mean is the ability of the athlete. \nThe variance is assumed to be $1$ for identifiability reasons. \n\nSimilar to our models of player/team strengths, the $\\theta_a$ are unidentifiable\nbecause we can add a constant to all the $\\theta_a$ without affect the \ndistribution of the ranks. \n\n### Bayesian approach\n\nIn contrast, to the approach we have used previously, we will introduce a\nBayesian approach that provides *weak* identifiability. \nWe introduce a prior for the $\\theta$s, namely\n$$\\theta_a \\stackrel{ind}{\\sim} N(0, 1).$$\nAn appealing aspect of this prior is that the $\\theta_a$ will now be \ninterpretable as how many standard deviations away from average (0) is an \nathlete. \n\n### Gibbs sampling\n\nMany Bayesian techniques estimate parameters using a technique called Gibbs\nsampling. \nTo perform Gibbs sampling, we alternate draws from the following\n*full conditional distributions*:\n\n- $p(\\theta|\\zeta, y)$\n- $p(\\zeta|\\theta, y)$\n\nwhere \n\n- $\\theta = (\\theta_1,\\ldots,\\theta_A)$ where $A$ is the number of athletes,\n- $\\zeta = (\\zeta_{11}, \\zeta_{21}, \\ldots, \\zeta_{N_11}, \\ldots, \\zeta_{1R}, \\ldots, \\zeta_{n_RR})$, and\n- $y = (y_{11}, y_{21}, \\ldots, y_{N_11}, \\ldots, y_{1R}, \\ldots, y_{n_R R})$.\n\nPerforming *iterations* of these draws will converge to a collection of draws\nfrom the *joint posterior distribution*\n$$p(\\theta,\\zeta|y).$$\nWe can take the $\\theta= (\\theta_1,\\ldots,\\theta_A)$ draws as our belief\nabout that players ability. \n\nNow, we need to determine what the two full conditional distributions are. \nDefine $\\zeta_a = \\{\\zeta_{a,e}: \\zeta_{a,e} \\mbox{ exists}\\}$ and \n$n_a = |\\zeta_a|$, which is the number of races athlete $a$ is in.\nFor the full conditional for $\\theta$, we have\n$$p(\\theta|\\zeta,y) = \\prod_{a=1}^A p(\\theta_a|\\zeta_a) = \\prod_{a=1}^A N\\left(\\theta_a; \\bar{\\zeta}_a, \\frac{1}{1+n_a}\\right).$$\nThus, the $\\theta_a$ are all **independent** draws from a normal distribution\nwhere the mean is the mean of the $\\zeta$ values for that athlete and the \nvariance is the inverse of the number of races plus 1 for that athlete. \nNote that, conditional on the $\\zeta$s, the $\\theta$s are independent of $y$. \n\nDefine $A_r$ be the set of athletes in race $r$.\nFor the full conditional for $\\zeta$, \nwe have \n$$p(\\zeta_{\\cdot,e}|\\theta,y) = \\left[\\prod_{a \\in A_r} N(\\zeta_{a,e}; \\theta_a, 1) \\right] \\mathrm{I}\\left(y_{a,e,(1)} < \\cdots < y_{a,e,(N_r)}\\right).$$\nThus, for each event, we draw the $\\zeta$s from independent normals with a \nmean according to that athlete, but with the requirement that the $\\zeta$\nmaintain the order observed in the race. \n\n### Computing\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Construct Gibbs sampler\n#' \n#' @param y is the observed R x A matrix of ranks\n#' @param n_iter integer, number of iterations to run\n#' \n#' @return A x (n_iter + 1) matrix of theta (player ability) draws\nrun_gibbs <- function(y, n_iter = 10, init = NULL) {\n  R <- nrow(y)\n  A <- ncol(y)\n  \n  # Storage\n  theta <- matrix(NA, nrow = n_iter + 1, ncol = A)\n  colnames(theta) <- colnames(y)\n  \n  # Initial draw\n  if (is.null(init)) {\n    init = sort(rnorm(A)) # if athletes are in order, this helps\n  }\n  theta[1, ] <- init\n  \n  # Precalculate quantities\n  sd_A <- sqrt(1 / (1 + colSums(!is.na(y))))\n  \n  # Iterations\n  for (i in 1:n_iter) {\n    zeta        <- sample_zeta(theta[i, ], y)\n    theta[i+1,] <- sample_theta(zeta, sd_A = sd_A)\n  }\n  \n  return(theta)\n}\n\n#' Check to make sure the zeta are in the correct order according to the ranks\n#' in y\n#' \n#' @param zeta numeric vector of player abilities\n#' @param y_r integer vector of ranks\n#' \n#' @return logical indicating if zeta is in the correct order\ncheck_zeta <- function(zeta, y_r) {\n  all(rank(zeta[!is.na(y_r)]) == y_r[!is.na(y_r)])\n}\n\n# Sample latent performances for each athlete in each race\n#' \n#' @param theta numeric vector of athlete abilities\n#' @param y integer matrix with athlete ranks in each event, \n#'   NAs indicate the athelete did not compete\n#'   \n#' @return numeric R x A matrix of player performances in each event\n#' \nsample_zeta <- function(theta, y) {\n  # Create zeta matrix\n  zeta <- y*0\n  R    <- nrow(zeta)\n  A    <- ncol(zeta)\n  \n  for (r in 1:R) {\n    for (a in 1:A) {\n      if (!is.na(y[r,a])) {\n        zeta_below <- ifelse(y[r,a] == 1, \n                             0, \n                             zeta[r, which(y[r,] == (y[r,a] - 1))])\n        \n        zeta_above <- ifelse(y[r,a] == max(y[r,], na.rm = TRUE), \n                             1, \n                             zeta[r, which(y[r,] == (y[r,a] - 1))])\n        \n        zeta[r, a] <- qnorm(runif(1, min = zeta_below, max = zeta_above), \n                            mean = theta[a])\n      }\n    }\n  }\n  \n  return(zeta)\n}\n\n#' Sample player abilities based on latent player performances\n#' \n#' @param zeta numeric R x A matrix of athlete performances, NAs indicate athlete did not perform\n#' @param sd_A numeric vector of pre-calculated standard deviations\n#' \n#' @return numeric vector of athlete abilities\n#' \nsample_theta <- function(zeta, sd_A) {\n  return(rnorm(ncol(zeta), \n               mean = colMeans(zeta, na.rm = TRUE), \n               sd   = sd_A))\n}\n```\n:::\n\n\n\n\n\n\n## Examples\n\n### Iowa State University Women's 2024 Cross-Country \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncc <- read_csv(\"../../data/2024WomensCC.csv\") |>\n  mutate(\n    race = factor(race, \n                  levels = c(\n                    \"2024CyclonePreview\",\n                    \"2024GreenoDirksenCrossCountryInvitational\",\n                    \"2024NuttycombeInvitationalChampionship\",\n                    \"2024WisconsinPreNationalsChampionship\",\n                    \"2024_Big_12_Conference_Cross_Country_Championship\",\n                    \"2024_NCAA_Division_I_Midwest_Region_Cross_Country_Championships\",\n                    \"2024_NCAA_Division_I_Cross_Country_Championships\"\n                  ))\n  ) |>\n  filter(TEAM == \"Iowa State\") |>\n  \n  # Create race-specific ranks\n  group_by(race) |>\n  mutate(\n    rank = order(TIME)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 1330 Columns: 12\n── Column specification ────────────────────────────────────────────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (5): NAME, YEAR, TEAM, t_sec, race\ndbl  (5): PL, t_min, SCORE, minutes, distance\ntime (2): Avg. Mile, TIME\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(cc, \n       aes(race, NAME, fill = rank)) +\n  geom_tile()\n```\n\n::: {.cell-output-display}\n![](rank_files/figure-html/cc-heatmap-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncc |> \n  group_by(NAME) |>\n  summarize(n = n()) |>\n  ggplot(aes(x = n)) +\n  geom_histogram(binwidth = 1) +\n  labs(\n    title = \"Iowa State University Women's 2024 Cross-Country\",\n    x = \"Number of Races\"\n  )\n```\n\n::: {.cell-output-display}\n![](rank_files/figure-html/cc-exploratory-number-of-races-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Construct rank matrix\ny <- cc |>\n  group_by(race) |>\n  mutate(rank = rank(minutes, na.last = \"keep\")) |>\n  select(race, NAME, rank) |>\n  \n  pivot_wider(names_from = NAME, \n              values_from = rank) \n\n# m <- run_gibbs(y[,-1])\n```\n:::\n",
    "supporting": [
      "rank_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}